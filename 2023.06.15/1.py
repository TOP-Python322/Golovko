nominals = {
    'Е6': (
        100, 150, 220, 330, 470, 680
    ),
    'E12': (
        100, 120, 150, 180, 220, 270, 330, 390, 470, 560, 680, 820
    ),
    'E24': (
        100, 110, 120, 130, 150, 160, 180, 200, 220, 240, 270, 300, 330, 360, 390, 430, 470, 510, 560, 620, 680, 750, 820, 910
    ),
    'E48': (
        100, 105, 110, 115, 121, 127, 133, 140, 147, 154, 162, 169, 178, 187, 196, 205, 215, 226, 237, 249, 261, 274, 287, 301, 316, 332, 348, 365, 383, 402, 422, 442, 464, 487, 511, 536, 562, 590, 619, 649, 681, 715, 750, 787, 825, 866, 909, 953
    ),
    'E96': (
        100, 102, 105, 107, 110, 113, 115, 118, 121, 124, 127, 130, 133, 137, 140, 143, 147, 150, 154, 158, 162, 165, 169, 174, 178, 182, 187, 191, 196, 200, 205, 210, 215, 221, 226, 232, 237, 243, 249, 255, 261, 267, 274, 280, 287, 294, 301, 309, 316, 324, 332, 340, 348, 357, 365, 374, 383, 392, 402, 412, 422, 432, 442, 453, 464, 475, 487, 499, 511, 523, 536, 549, 562, 576, 590, 604, 619, 634, 649, 665, 681, 698, 715, 732, 750, 768, 787, 806, 825, 845, 866, 887, 909, 931, 953, 976
    )
}
# УДАЛИТЬ: не уверен, что именно вы здесь записали — разность между ближайшими номиналами в ряду? но эта разность не является постоянным числом, потому что ряд не является прогрессией: ни арифметической, ни геометрической — значения этих номиналов имеют сугубо технологическую природу
faults = {'Е6': 20, 'E12': 10, 'E24': 5, 'E48': 2, 'E96': 1}


def pick_resistors(resistance: int) -> dict | None:
    # ИСПОЛЬЗОВАТЬ: переносы строк в документации и комментариях помещаются только между абзацами — используйте перенос строк (soft wrap)
    """Pick the suitable value of resistor from several precision lists"""
    # ИСПРАВИТЬ: конструирование последовательности выполняется хоть и быстро, но всё же не мгновенно — двойное неравенство здесь будет заметно эффективнее
    if resistance not in range(100, 1000):
        return None
    
    result = dict()
    # ПЕРЕИМЕНОВАТЬ: переменным требуется давать имена по смыслу, так чтобы код можно было удобнее и быстрее читать — имя item вводит в заблуждение о значении, ассоциированном с данной переменной — стоило назвать переменную label
    # ИСПРАВИТЬ: использование словарного метода items() могло бы избавить вас от необходимости отдельно объявлять переменную row
    for item in nominals.keys():
        # ИСПОЛЬЗОВАТЬ: имя _ не должно применяться вместо значащих имён переменных
        row = nominals[item]
        # ИСПОЛЬЗОВАТЬ: имя _ используют, когда переменная для нас не важна, например, в качестве не используемой переменной цикла
        # КОММЕНТАРИЙ: имена i, j, k традиционно используются только для индексов — не нарушайте эту традицию
        # УДАЛИТЬ: действия в теле цикла на каждой итерации повторяются одинаковым образом, без всяческой пользы — цикл не нужен
        for _ in row:
            # ПЕРЕИМЕНОВАТЬ: переменным требуется давать имена по смыслу, так чтобы код можно было удобнее и быстрее читать — имя t ничего не говорит о том, какое значение ассоциировано с данной переменной — вместо него стоило назвать переменную picked
            # УДАЛИТЬ: нет никакой необходимости в данной математике, а искажения она вносит (см. тест ниже)
            t = tuple(filter(
                # ИСПОЛЬЗОВАТЬ: Python поддерживает математическую запись двойных(, тройных и т.д.) неравенств
                # КОММЕНТАРИЙ: если бы словарь faults имел смысл, то стоило бы сразу записать в него результат деления соответствующего значения на 100 — повторение этой операции на каждой итерации совершенно очевидно является избыточным
                lambda x: x*(1 - faults[item]/100) <= resistance <= x*(1 + faults[item]/100),
                row
            ))
            # ИСПРАВИТЬ: любой объект Python может быть приведён к логическому значению (https://docs.python.org/3/library/stdtypes.html#truth-value-testing) — помимо прочего это позволяет намного проще проверить любой контейнер на наличие в нём элементов
            if t == ():
                # ИСПРАВИТЬ: встроенная функция min() может принимать в качестве аргумента любой итерируемый объект — преобразование в список избыточно
                min_diff = min(list(map(lambda x: abs(x - resistance), row)))
                t = tuple(filter(lambda x: abs(x - resistance) == min_diff, row))
            result.update({item:t})
    return result


# ИСПОЛЬЗОВАТЬ везде: комментарии вместо строковых литералов
# >>> pick_resistors(112)
# {'Е6': (100,), 'E12': (120,), 'E24': (110,), 'E48': (110,), 'E96': (113,)}

# >>> pick_resistors(549)
# КОММЕНТАРИЙ: в ряду Е6 должно быть только одно ближайшее значение: 470 — разность между 680 и 549 больше, чем между 549 и 470
# {'Е6': (470, 680), 'E12': (560,), 'E24': (560,), 'E48': (536, 562), 'E96': (549,)}

# ДОБАВИТЬ везде и всегда: тесты не только по примерам, но для всех возможных ситуаций, например:
# >>> print(pick_resistors(1))
# None


# КОММЕНТАРИЙ: следите за всеми правками включая стилистические в домашних заданиях и в дальнейшем пишите по аналогии с исправленным кодом


# ИТОГ: неплохо, но нужно лучше — 2/4
